
= プログラムと評価


== プログラミング言語とは

プログラミング言語とはプログラムを書くための言語です。プログラミング言語の処理系とは、与えられたプログラムを計算するもので、コンパイラと実行系の組み合わせで計算したり、インタープリタで計算したりします。本書ではプログラムを逐次解釈し実行していくインタープリタを作って行きます。これは、与えられたプログラムの動作を規定するものですので、見方を変えれば、処理系であるインタープリタによりプログラミング言語を定義しているとも言えます@<fn>{fn1}。

次にプログラムとは何か、という観点で上の文章を言い換えてみます。プログラムは計算するための手順をしるしたものと言われていますが、本文書ではこれとは異なる方法で定義します。すなわち、プログラムが与えられたをとき、それをどう実行するかを定義します。今回は、自然言語で書かれた仕様書ではなく、Rubyのプログラムによって、何をプログラムとして受け入れ、それがどう実行されるのかを定めます。これにより、自然言語に含まれるあいまいさがなく、プログラムとは何かを定めることができます。

はじめから全てのプログラムを対象にすると理解が難しいので、簡単なプログラムの例を示しながら、それが動くように少しずつ機能を追加していきます。

「プログラミング言語の処理系」なんて難しく考えないでください。要は、文字列を読み込んで、それを計算するプログラムです。電卓に毛が生えたものと思えば気も楽になりませんか。最初はまさに電卓の例から考えてみます。


== はじめてのプログラムの評価

最初のプログラムとして次のプログラムを考えます。

//emlist{
[:+, 1, 2]
//}

今までのプログラムと全く異なる記述方法に戸惑うことでしょう。当然です。これは著者が勝手に考えたμSchemeR(名前も勝手に考えました)というプログラミング言語だからです。気にくわない書き方だと思いますが、この文書を読み終わるころには、自分の好きな書き方へ直す力が身についていると思いますので少しお付き合い下さい。

ただ少し想像力を働かせれば、1と2を足し合わせるプログラムなのだと想像できるのではないでしょうか。そのとおり、正解です。では、「このプログラムを与えられた時にこの結果を求める処理を考えて下さい」と言われたとき、どう答えるでしょうか。「1と2を足し合わせた結果を求める」もしくは「@<tt>{:+}が先頭にあった時、続く2つの引数の値を足し合わせる」とも言えるでしょう。

では、次のプログラムの結果を求める処理はどうでしょう。

//emlist{
[:+, [:+, 1, 2], 3]
//}

「まず@<tt>{[:+, 1, 2]}を計算してその結果と3とを足し合わせる」と言えるでしょう。ここで前回の説明に「計算して」という言葉が加わったことに気づいたでしょうか。すなわち、上2つのプログラムの計算結果を求める処理を考えたとき、その処理は@<tt>{:+}に続く引数を「計算」した後に足し合わせる必要があるのです。通常、我々はこの計算のことを「評価(evaluation)」と言います。したがって、「@<tt>{:+}が先頭にあった時、続く2つの引数を評価して、その値を足し合わせる」が求める処理です。

====[column]μSchemeRのシンタックス

今回作成するプログラミング言語μSchemeRでは、@<tt>{[:+, 1, 2]}などのように最初に関数を、その後引数を記述します。なぜ、このようなスタイルなのでしょう。

他言語のように@<tt>{x + y * z}と書かかれたものを計算するためには@<tt>{(x + y) * z}なのか@<tt>{x + (y * z)}なのかを演算子の優先度を考慮して決める必要があります。さらに言えば、後に出てくるif文も@<tt>{[:if, :true,  1, 0]}などのように必ず@<tt>{[}の後に@<tt>{:if}のようなキーワードが出てくるので、この文字列を見れば通常の関数適用なのか、特殊な構文なのかを簡単に解釈できます。一方で、@<tt>{if (true) then 1 else 2;やx = y + 1;}などのように色々な形の構文を許すとそれがどのような構文なのかを解釈するために多くの計算(字句解析/構文解析)が必要になってきます。計算機がこの処理をせずに人間がこの作業をすることで、計算機側は簡単な処理でそれを解釈できるようになっていると言うわけです(このことは計算機がすべきことを人間が苦労を強いられているという単純な話ではありません。なぜならプログラミング言語の仕様が単純になるため、結果的に言語仕様を学習する労力が削減されるためです。言語習得の容易さとプログラムの書きやすさのバランスが求められるのかもしれません)。

また、要素は「,」で区切り、それらを「[」と「]」で囲み、リストを表します。この形式は、Rubyで配列としてそのまま扱えるため、計算機側で余計な処理を考えなくて良くなります。また、記号である@<tt>{+}や変数である@<tt>{x}や予約語@<tt>{if}などは、単語のはじめに@<tt>{:}をつけてそれぞれ@<tt>{:+}、@<tt>{:x}、@<tt>{:if}と記します。この表記法もRubyでそのままシンボルとして扱えるために導入しています。

====[/column]

それでは、このプログラムの結果を求める処理をRubyで記述してみましょう。

@<tt>{_eval}@<fn>{fn2}は、与えられた式@<tt>{exp}を評価し、その結果を返します。

式がリストであった場合、最初の要素を関数として、残りを引数として、それぞれを評価してその値を求めます。求めた関数に求めた引数の値を適用(apply)してその結果を@<tt>{_eval}の結果とします@<fn>{fn3}。一方、リストでない場合、数字であれば即値として扱い数字そのものを返します。例えば2は2を返します。そうでなければ、組み込み関数とみなし、それに関連付けられた(Ruby上での)関数を返します。

//emlist{
def _eval(exp)
  if not list?(exp) 
    if immediate_val?(exp)
      exp
    else 
      lookup_primitive_fun(exp)
    end
  else
    fun = _eval(car(exp))
    args = eval_list(cdr(exp))
    apply(fun, args)
  end
end
//}

//note[プログラムコードと値の区別]{
「2は2を返します」という文章で数字のフォントが違っていることに気づきましたか? 2は(現在考えているμSchemeR)プログラムの、2は(Ruby上での)数値の2を表します。こう記載することによって、プログラムとその評価された値とを区別します。@<img>{uschemer_ruby}を確認してください。
//}

以降、上のRubyプログラムで呼ばれている関数を説明していきます。

リストかどうかは配列のインスタンスかどうかで判断しています。

//emlist{
def list?(exp)
  exp.is_a?(Array)
end
//}

組み込み関数は、関数名をキーに、関数本体をその値としたハッシュで保有しま す。関連付けられている関数はRuby上での関数です。組み込み関数の評価は、 関数名に関連付けられた関数を値として返します。

//emlist{
def lookup_primitive_fun(exp)
  $primitive_fun_env[exp]
end

$primitive_fun_env = {
  :+ => [:prim, lambda{|x, y| x + y}],
  :- => [:prim, lambda{|x, y| x - y}],
  :* => [:prim, lambda{|x, y| x * y}], 
}
//}

@<tt>{car}はリストの先頭の要素を、cdrは先頭の要素以降のリストを取得する関数です。この名前は奇妙@<fn>{fn4} ですが、Schemeで使われている名前ですので我慢してください。そのうち慣れてくるでしょう。

//emlist{
def car(list)
  list[0]
end

def cdr(list)
  list[1..-1]
end
//}

引数を評価する@<tt>{eval_list}は、リストの要素それぞれを評価したものをリストにしたものです。

//emlist{
def eval_list(exp)
  exp.map{|e| _eval(e)}
end    
//}

そのままの値を返す即値として数字を定義しています。

//emlist{
def immediate_val?(exp)
  num?(exp) 
end

def num?(exp)
  exp.is_a?(Numeric)
end
//}

関数適用は、引数の評価値(Ruby上の値になります)を(Ruby上の)関数へ適用しています。@<tt>{fun_val.call(*args)}は、@<tt>{fun_val}というRuby上の関数を引数@<tt>{args}で呼び出します。は、可変長引数に対応しており、@<tt>{args}が@<tt>{[1, 2}の場合fun_val.call(1, 2)と展開され、@<tt>{args}が@<tt>{[1, 2, 3]}の場合@<tt>{fun_val.call(1, 2, 3)}と展開されます。

//emlist{
def apply(fun, args)
  apply_primitive_fun(fun, args)
end

def apply_primitive_fun(fun, args)
  fun_val = fun[1]
  fun_val.call(*args)
end
//}

実際に、@<tt>{[:+, 1, 2]}を評価するときの動きを図[fig:uschemer@<sub>{r}uby]を見ながら追ってみましょう。与えるプログラムはリストですので、まず先頭の要素:+を評価し、@<m>{lambda{|x, y| x + y\}}を値として得ます。これは、二つの引数を足す(Ruby上の)関数です。次に@<tt>{1}, @<tt>{2}を評価し、それぞれ(Ruby上での)1, 2を得ます。これを(Ruby上で)適用することで、3を得ます。この値はputsを使って、Ruby上のプログラムで表示することができます@<fn>{fn5}。

//image[uschemer_ruby][プログラミング言語の世界μSchemeRと評価値の世界Rubyとの関係]{
//}

//emlist{
puts _eval([:+, 1, 2])
//}

を実行して3が表示されましたか。おめでとうございます。おそらく、あなたははじめてプログラミング言語のインタープリタを作ったのではないでしょうか。足し算程度しかできないプログラミング言語なので実感は無いかもしれませんが、正真正銘のプログラミング言語の処理系です。

@<tt>{[:+, [:+, 1, 2], 3]}が評価される流れも自分で追ってみて下さい。@<tt>{_eval}が再帰的に呼ばれている点が役立っていることに気づけましたか。


== まとめ

この章では次のことを学びました。

 *  簡単なプログラムの計算方法(また、我々はこの計算を「評価」と呼びました)
 *  関数適用の評価方法、すなわち、関数と引数を評価して、得られた関数の評価値に引数の評価値を関数適用するということ
 *  プログラムが評価されると(プログラムの実行結果はRubyという)他の世界の値として得られること


普段何気なく書いている@<tt>{x = y;}というプログラムは、実際は右辺をまず評価してその値を左辺の変数のアドレスに格納する、ということを行っています。漠然とは理解していたと思いますが、実際は本章で学んだ評価という考え方などに基づいてプログラムは実行されています。その内部を少し垣間見ることができたのではないでしょうか。


//footnote[fn1][これをプログラミング言語を操作的意味論(operetional semantics)で定義すると言います。]

//footnote[fn1a][このことは計算機がすべきことを人間が苦労を強いられているという単純な話ではありません。なぜならプログラミング言語の仕様が単純になるため、結果的に言語仕様を学習する労力が削減されるためです。言語習得の容易さとプログラムの書きやすさのバランスが求められるのかもしれません。]

//footnote[fn1b][Ruby では:に文字列を続けることで、それを定数のように扱えるシンボルという機能が存在します。シンボルを使わない場合、x を評価するとRuby 上の変数として評価されるため、x がRuby で定義されていない場合エラーになるため扱いが面倒となります。]

//footnote[fn2][evalとしないで_evalとしているのは、Rubyの組み込み関数としてevalが定義されているためです。気になる人は、Rubyのmodule機能を使って名前空間を分け、_evalをevalとして定義しなおして下さい。またその際は、p. のparseで使われるevalはKernel::evalに置き換えて下さい。]

//footnote[fn3][Rubyでは、関数の最後に評価した式の値が関数の返り値になります。一般的に関数型言語ではreturn @<b>{<値>}と書かずに、このような書き方をします。本書では、関数型言語の考え方に近づくようにこの記述を利用していきます。]

//footnote[fn4][carはContents of the Address part of Register、cdrはContents of the Decrement part of Register、後で出てくるconsはCONStructから来ています。これらはLispが開発されたIBMの計算機の機械語に由来しています。]

//footnote[fn5][今回作成しているμSchemeR上でも、表示できるようにしますが、後のお楽しみとします。]


